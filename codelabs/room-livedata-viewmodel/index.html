
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TP 04.2A: Room, LiveData and ViewModel</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-T70T90JTWB"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-T70T90JTWB');
  </script>
</head>
<body>
  <google-codelab-analytics gaid="UA-3295395-7"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="room-livedata-viewmodel"
                  title="TP 04.2A: Room, LiveData and ViewModel"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Bienvenue" duration="0">
        <p>Ces travaux pratiques se base sur le cours de base pour les développeurs Android fourni par Google afin de  les préparer pour le test de certification <a href="https://developers.google.com/training/certification/associate-android-developer/" target="_blank">Associate Android Developer</a>. Vous obtiendrez le plus de valeur de ce TP si vous travaillez successivement dans les codelabs.</p>
<h2 is-upgraded>Introduction</h2>
<p>The Android operating system provides a strong foundation for building apps that run well on a wide range of devices and form factors. However, issues like complex lifecycles and the lack of a recommended app architecture make it challenging to write robust apps. The <a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank">Android Architecture Components</a> provide libraries for common tasks such as lifecycle management and data persistence to make it easier to implement the <a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank">recommended architecture</a>.</p>
<p>Architecture Components help you structure your app in a way that is robust, testable, and maintainable with less boilerplate code.</p>
<h3 is-upgraded>What are the recommended Architecture Components?</h3>
<p>When it comes to architecture, it helps to see the big picture first. To introduce the terminology, here&#39;s a short overview of the Architecture Components and how they work together. Each component is explained more as you use it in this practical.</p>
<p>The diagram below shows a basic form of the recommended architecture for apps that use Architecture Components. The architecture consists of a UI controller, a <code>ViewModel</code> that serves <code>LiveData</code>, a Repository, and a Room database. The Room database is backed by an SQLite database and accessible through a data access object (DAO). Each component is described briefly below, and in detail in the Architecture Components concepts chapter, <a href="https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-4-saving-user-data/lesson-10-storing-data-with-room/10-1-c-room-livedata-viewmodel/10-1-c-room-livedata-viewmodel.html" target="_blank">Storing data with Room</a>. You implement the components in this practical.</p>
<p class="image-container"><img style="width: 624.00px" src="img/25beb0344c741aaa.png"></p>
<p>Because all the components interact, you will encounter references to these components throughout this practical, so here is a short explanation of each.</p>
<p><em>Entity:</em> In the context of Architecture Components, the entity is an annotated class that describes a database table.</p>
<p><em>SQLite database:</em> On the device, data is stored in an SQLite database. The <a href="https://developer.android.com/training/data-storage/room/index.html" target="_blank">Room persistence library</a> creates and maintains this database for you.</p>
<p><em>DAO:</em> Short for <em>data access object</em>. A mapping of SQL queries to functions. You used to have to define these queries in a helper class. When you use a DAO, your code calls the functions, and the components take care of the rest.</p>
<p><em>Room database:</em> Database layer on top of an SQLite database that takes care of mundane tasks that you used to handle with a helper class. The Room database uses the DAO to issue queries to the SQLite database based on functions called.</p>
<p><em>Repository:</em> A class that you create for managing multiple data sources. In addition to a Room database, the Repository could manage remote data sources such as a web server.</p>
<p><em><code>ViewModel</code></em><em>:</em> Provides data to the UI and acts as a communication center between the Repository and the UI. Hides the backend from the UI. <code>ViewModel</code> instances survive device configuration changes.</p>
<p><em><code>LiveData</code></em><em>: </em>A data holder class that follows the <a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank">observer pattern</a>, which means that it can be observed. Always holds/caches latest version of data. Notifies its observers when the data has changed. Generally, UI components observe relevant data. <code>LiveData</code> is lifecycle-aware, so it automatically manages stopping and resuming observation based on the state of its observing activity or fragment.</p>
<h2 is-upgraded>What you should already know</h2>
<p>You should be able to create and run apps in <a href="https://developer.android.com/studio/index.html" target="_blank">Android Studio 3.0 or higher</a>. In particular, be familiar with:</p>
<ul>
<li><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" target="_blank"><code>RecyclerView</code></a> and adapters</li>
<li><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html" target="_blank">SQLite databases</a> and the SQLite query language</li>
<li>Threading in general, and <a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank"><code>AsyncTask</code></a> in particular</li>
</ul>
<p>It helps to be familiar with:</p>
<ul>
<li>Software architectural patterns that separate data from the UI.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank">observer pattern</a>. In summary, the observer pattern defines a one-to-many dependency between objects. Whenever an object changes its state, all the object&#39;s dependents are notified and updated automatically. The main object is called the &#34;subject&#34; and its dependents are called the &#34;observers.&#34; Usually, the subject notifies the observers by calling one of the observers&#39; methods. The subject knows what methods to call, because the observers are &#34;registered&#34; with the subject and specify the methods to call.</li>
</ul>
<aside class="warning"><p><strong>Important</strong>: This practical implements the architecture defined in the <a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank">Guide to App Architecture</a> and explained in the Architecture Components concepts chapter, <a href="https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-4-saving-user-data/lesson-10-storing-data-with-room/10-1-c-room-livedata-viewmodel/10-1-c-room-livedata-viewmodel.html" target="_blank">Storing data with Room</a>. It is highly recommended that you read the concepts chapter.</p>
</aside>
<h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>How to design and construct an app using some of the Android Architecture Components. You&#39;ll use <a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank">Room</a>, <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank"><code>ViewModel</code></a>, and <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank"><code>LiveData</code></a>.</li>
</ul>
<h2 is-upgraded>What you&#39;ll do</h2>
<ul>
<li>Create an app with an <code>Activity</code> that displays words in a <code>RecyclerView</code>.</li>
<li>Create an <code>Entity</code> that represents word objects.</li>
<li>Define the mapping of SQL queries to Java methods in a DAO (data access object).</li>
<li>Use <code>LiveData</code> to make changes to the data visible to the UI, by way of observers.</li>
<li>Add a Room database to the app for persisting data locally, and initialize the database.</li>
<li>Abstract the data backend as a <code>Repository</code> class with an API that is agnostic to how the data is stored or acquired.</li>
<li>Use a <code>ViewModel</code> to separate all data operations from the UI.</li>
<li>Add a second <code>Activity</code> that allows the user to add new words.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Aperçu de l&#39;application" duration="0">
        <p>In this practical you build an app that uses the <a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank">Android Architecture Components</a>. The app, called RoomWordsSample, stores a list of words in a Room database and displays the list in a <code>RecyclerView</code>. The RoomWordsSample app is basic, but sufficiently complete that you can use it as a template to build on.</p>
<p>The RoomWordsSample app does the following:</p>
<ul>
<li>Works with a database to get and save words, and pre-populates the database with some words.</li>
<li>Displays all the words in a <code>RecyclerView</code> in <code>MainActivity</code>.</li>
<li>Opens a second <code>Activity</code> when the user taps the <code>+</code> FAB button. When the user enters a word, the app adds the word to the database and then the list updates automatically.</li>
</ul>
<p>The screenshots below show the following:</p>
<ul>
<li>The RoomWordsSample app as it starts, with the initial list of words</li>
<li>The activity to add a word</li>
</ul>
<table>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 288.00px" src="img/abf24350514167bf.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 288.00px" src="img/f59f81ad6aadfe12.png"></p>
</td></tr>
</table>
<h2 is-upgraded>RoomWordsSample architecture overview</h2>
<p>The following diagram mirrors the overview diagram from the introduction and shows all the pieces of the RoomWordsSample app. Each of the enclosing boxes (except for the SQLite database) represents a class that you create.</p>
<aside class="special"><p><strong>Tip</strong>: Print or open this diagram in a separate tab so you can refer to it as you build the code.</p>
</aside>
<p class="image-container"><img style="width: 558.00px" src="img/cc45ecfbf5889f07.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 1: Create the RoomWordsSample app" duration="0">
        <aside class="special"><p><strong>Note</strong>: In this practical, you are expected to create member variables, import classes, and extract values as needed. Code that you are expected to be familiar with is provided but not explained.</p>
</aside>
<h2 is-upgraded>1.1 Create an app with one Activity</h2>
<p>Open Android Studio and create an app. On the setup screens, do the following:</p>
<ul>
<li>Name the app <strong>RoomWordsSample</strong>.</li>
<li>If you see check boxes for <strong>Include Kotlin support</strong> and <strong>Include C++ support</strong>, uncheck both boxes.</li>
<li>Select only the <strong>Phone &amp; Tablet</strong> form factor, and set the minimum SDK to API 14 or higher.</li>
<li>Select the <strong>Basic Activity</strong>.</li>
</ul>
<h2 is-upgraded>1.2 Update Gradle files</h2>
<p>In Android Studio, manually add the Architecture Component libraries to your Gradle files.</p>
<ol type="1" start="1">
<li>Add the following code to your <code>build.gradle (Module: app)</code> file, to the bottom of the dependencies block (but still inside it).</li>
</ol>
<pre><code>// Room components
//use androix instead
implementation &#34;androidx.room:room-runtime:$roomVersion&#34;
annotationProcessor &#34;androidx.room:room-compiler:$roomVersion&#34;
// Test helpers
testImplementation &#34;androidx.room:room-testing:$roomVersion&#34;



// Lifecycle components
// ViewModel and LiveData
implementation &#34;androidx.lifecycle:lifecycle-extensions:$archLifecycleVersion&#34;
annotationProcessor &#34;androidx.lifecycle:lifecycle-common-java8:2.5.1&#34;</code></pre>
<ol type="1" start="2">
<li>In your <code>build.gradle (Project: RoomWordsSample)</code> file, add the version numbers at the end of the file.</li>
</ol>
<pre><code>ext {
   roomVersion = &#39;2.4.3&#39;
   archLifecycleVersion = &#39;2.2.0&#39;
}</code></pre>
<aside class="warning"><p><strong>Important</strong>: Use the latest version numbers for the Room and lifecycle libraries. To find the latest version numbers:</p>
</aside>
<ol type="1" start="1">
<li>On the <a href="https://developer.android.com/topic/libraries/architecture/adding-components.html" target="_blank">Adding Components to your Project</a> page, find the entry for the component, for example Room.</li>
<li>The version number is defined at the start of the component&#39;s <code>dependencies</code> definition. For example, the Room version number in the definition below is 2.2.1:<br><code>def room_version = &#34;2.2.1&#34;</code></li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 2: Create the Word entity" duration="0">
        <p>The diagram below is the complete architecture diagram with the component that you are going to implement in this task highlighted. Every task will have such a diagram to help you understand where the current component fits into the overall structure of the app, and to see how the components are connected.</p>
<p class="image-container"><img style="width: 446.00px" src="img/f1b959050ea83a6d.png"></p>
<p>The data for this app is words, and each word is represented by an entity in the database. In this task you create the <code>Word</code> class and annotate it so Room can create a database table from it. The diagram below shows a <code>word_table</code> database table. The table has one <code>word</code> column, which also acts as the primary key, and two rows, one each for &#34;Hello&#34; and &#34;World.&#34;</p>
<p class="image-container"><img style="width: 334.00px" src="img/a5028695bbe21c36.png"></p>
<h2 is-upgraded>2.1 Create the Word class</h2>
<ol type="1" start="1">
<li>Create a class called <code>Word</code>.</li>
<li>Add a constructor that takes a <code>word</code> string as an argument. Add the <code>@NonNull</code> <a href="https://developer.android.com/reference/android/support/annotation/package-summary.html" target="_blank">annotation</a> so that the parameter can never be <code>null</code>.</li>
<li>Add a &#34;getter&#34; method called <code>getWord()</code>that returns the word. Room requires &#34;getter&#34; methods on the entity classes so that it can instantiate your objects.</li>
</ol>
<pre><code>public class Word {
   private String mWord;
   public Word(@NonNull String word) {this.mWord = word;}
   public String getWord(){return this.mWord;}
}</code></pre>
<h2 is-upgraded>2.2 Annotate the Word class</h2>
<p>To make the <code>Word</code> class meaningful to a Room database, you must annotate it. Annotations identify how each part of the <code>Word</code> class relates to an entry in the database. Room uses this information to generate code.</p>
<p>You use the following annotations in the steps below:</p>
<ul>
<li><code>@Entity(tableName = &#34;</code><strong><code>word_table</code></strong><code>&#34;)</code><br>Each <code>@Entity</code> class represents an entity in a table. Annotate your class declaration to indicate that the class is an entity. Specify the name of the table if you want it to be different from the name of the class.</li>
<li><code>@PrimaryKey</code><br>Every entity needs a primary key. To keep things simple, each word in the RoomWordsSample app acts as its own primary key. To learn how to auto-generate unique keys, see the tip below.</li>
<li><code>@NonNull</code><br>Denotes that a parameter, field, or method return value can never be null. The primary key should always use this annotation. Use this annotation for any mandatory fields in your rows.</li>
<li><code>@ColumnInfo(name = &#34;</code><strong><code>word</code></strong><code>&#34;)</code><br>Specify the name of a column in the table, if you want the column name to be different from the name of the member variable.</li>
<li>Every field that&#39;s stored in the database must either be public or have a &#34;getter&#34; method. This app provides a <code>getWord()</code> &#34;getter&#34; method rather than exposing member variables directly.</li>
</ul>
<p>For a complete list of annotations, see the <a href="https://developer.android.com/reference/android/arch/persistence/room/package-summary.html" target="_blank">Room package summary reference</a>.</p>
<p>Update your <code>Word</code> class with annotations, as shown in the code below.</p>
<ol type="1" start="1">
<li>Add the <code>@Entity</code> notation to the class declaration and set the <code>tableName</code> to <code>&#34;word_table&#34;</code>.</li>
<li>Annotate the <code>mWord</code> member variable as the <code>@PrimaryKey</code>. Require <code>mWord</code> to be <code>@NonNull</code>, and name the column <code>&#34;word&#34;</code>.</li>
</ol>
<aside class="special"><p><strong>Note</strong>: If you type in the annotations, Android Studio auto-imports everything you need.</p>
</aside>
<p>Here is the complete code:</p>
<pre><code>@Entity(tableName = &#34;word_table&#34;)
public class Word {

   @PrimaryKey
   @NonNull
   @ColumnInfo(name = &#34;word&#34;)
   private String mWord;

   public Word(@NonNull String word) {this.mWord = word;}

   public String getWord(){return this.mWord;}
}</code></pre>
<p>If you get errors for the annotations, you can import them manually, as follows:</p>
<pre><code>
//use androidx instead
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.PrimaryKey;
import androidx.annotation.NonNull;</code></pre>
<aside class="special"><p><strong>Tip on auto-generating keys</strong>: To <a href="https://developer.android.com/reference/android/arch/persistence/room/PrimaryKey.html" target="_blank">auto-generate</a> a unique key for each entity, you would add and annotate a primary integer key with <code>autoGenerate=true</code>. See <a href="https://developer.android.com/training/data-storage/room/defining-data.html" target="_blank">Defining data using Room entities</a>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 3: Create the DAO" duration="0">
        <p class="image-container"><img style="width: 421.00px" src="img/bc6447c1391a1b5b.png"></p>
<p>The data access object, or <a href="https://developer.android.com/reference/android/arch/persistence/room/Dao.html" target="_blank"><code>Dao</code></a>, is an annotated class where you specify SQL queries and associate them with method calls. The compiler checks the SQL for errors, then generates queries from the annotations. For common queries, the libraries provide convenience annotations such as <code>@Insert</code>.</p>
<p>Note that:</p>
<ul>
<li>The DAO must be an <code>interface</code> or <code>abstract</code> class.</li>
<li>Room uses the DAO to create a clean API for your code.</li>
<li>By default, all queries (<code>@Query</code>) must be executed on a thread other than the main thread. (You work on that later.) For operations such as inserting or deleting, if you use the provided convenience annotations, Room takes care of thread management for you.</li>
</ul>
<h2 is-upgraded>3.1 Implement the DAO class</h2>
<p>The DAO for this practical is basic and only provides queries for getting all the words, inserting words, and deleting all the words.</p>
<ol type="1" start="1">
<li>Create a new <code>interface</code> and call it <code>WordDao</code>.</li>
<li>Annotate the class declaration with <code>@Dao</code> to identify the class as a DAO class for Room.</li>
<li>Declare a method to insert one word:</li>
</ol>
<pre><code>void insert(Word word);</code></pre>
<ol type="1" start="4">
<li>Annotate the <code>insert()</code> method with <code>@Insert</code>. You don&#39;t have to provide any SQL! (There are also <code>@</code><a href="https://developer.android.com/reference/android/arch/persistence/room/Delete.html" target="_blank"><code>Delete</code></a> and <code>@</code><a href="https://developer.android.com/reference/android/arch/persistence/room/Update.html" target="_blank"><code>Update</code></a> annotations for deleting and updating a row, but you do not use these operations in the initial version of this app.)</li>
<li>Declare a method to delete all the words:</li>
</ol>
<pre><code>void deleteAll();</code></pre>
<ol type="1" start="6">
<li>There is no convenience annotation for deleting multiple entities, so annotate the <code>deleteAll()</code> method with the generic <code>@Query</code>. Provide the SQL query as a string parameter to <code>@Query</code>. Annotate the <code>deleteAll()</code> method as follows:</li>
</ol>
<pre><code>@Query(&#34;DELETE FROM word_table&#34;)</code></pre>
<ol type="1" start="7">
<li>Create a method called <code>getAllWords()</code> that returns a <code>List</code> of <code>Words</code>:</li>
</ol>
<pre><code>List&lt;Word&gt; getAllWords();</code></pre>
<ol type="1" start="8">
<li>Annotate the <code>getAllWords()</code> method with an SQL query that gets all the words from the <code>word_table</code>, sorted alphabetically for convenience:</li>
</ol>
<pre><code>@Query(&#34;SELECT * from word_table ORDER BY word ASC&#34;)</code></pre>
<p>Here is the completed code for the <code>WordDao</code> class:</p>
<pre><code>@Dao
public interface WordDao {

   @Insert
   void insert(Word word);

   @Query(&#34;DELETE FROM word_table&#34;)
   void deleteAll();

   @Query(&#34;SELECT * from word_table ORDER BY word ASC&#34;)
   List&lt;Word&gt; getAllWords();
}</code></pre>
<aside class="special"><p><strong>Tip</strong>: For this app, ordering the words is not strictly necessary. However, by default, return order is not guaranteed, and ordering makes testing straightforward.</p>
</aside>
<p>To learn more about DAOs, see <a href="https://developer.android.com/training/data-storage/room/accessing-data.html" target="_blank">Accessing data using Room DAOs</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 4: Use LiveData" duration="0">
        <p class="image-container"><img style="width: 380.00px" src="img/e233bc799bf3377a.png"></p>
<p>When you display data or use data in other ways, you usually want to take some action when the data changes. This means you have to observe the data so that when it changes, you can react.</p>
<p><code>LiveData</code>, which is a <a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" target="_blank">lifecycle library </a>class for data observation, can help your app respond to data changes. If you use a return value of type <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank"><code>LiveData</code></a> in your method description, Room generates all necessary code to update the <code>LiveData</code> when the database is updated.</p>
<h2 is-upgraded>4.1 Return LiveData in WordDao</h2>
<ul>
<li>In the <code>WordDao</code> interface, change the <code>getAllWords()</code> method signature so that the returned <code>List&lt;Word&gt;</code> is wrapped with <code>LiveData&lt;&gt;</code>.</li>
</ul>
<pre><code>  @Query(&#34;SELECT * from word_table ORDER BY word ASC&#34;)
   LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</code></pre>
<p>See the <a href="https://developer.android.com/topic/libraries/architecture/livedata.html" target="_blank"><code>LiveData</code></a> documentation to learn more about other ways to use <code>LiveData</code>, or watch this <a href="https://www.youtube.com/watch?v=jCw5ib0r9wg" target="_blank">Architecture Components: LiveData and Lifecycle</a> video.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 5: Add a Room database" duration="0">
        <p class="image-container"><img style="width: 465.00px" src="img/368cd59119178a42.png"></p>
<p>Room is a database layer on top of an SQLite database. Room takes care of mundane tasks that you used to handle with a database helper class such as <a href="https://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank"><code>SQLiteOpenHelper</code></a>.</p>
<ul>
<li>Room uses the DAO to issue queries to its database.</li>
<li>By default, to avoid poor UI performance, Room doesn&#39;t allow you to issue database queries on the main thread. <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank"><code>LiveData</code></a> applies this rule by automatically running the query asynchronously on a background thread, when needed.</li>
<li>Room provides compile-time checks of SQLite statements.</li>
<li>Your <code>Room</code> class must be abstract and extend <code>RoomDatabase</code>.</li>
<li>Usually, you only need one instance of the Room database for the whole app.</li>
</ul>
<h2 is-upgraded>5.1 Implement a Room database</h2>
<ol type="1" start="1">
<li>Create a <code>public abstract</code> class that extends <a href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.html" target="_blank"><code>RoomDatabase</code></a> and call it <code>WordRoomDatabase</code>.</li>
</ol>
<pre><code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></pre>
<ol type="1" start="2">
<li>Annotate the class to be a Room database. Declare the entities that belong in the database—in this case there is only one entity, <code>Word</code>. (Listing the <code>entities</code> class or classes creates corresponding tables in the database.) Set the version number. Also set export schema to <code>false</code>, <code>exportSchema</code> keeps a history of schema versions. For this practical you can disable it, since you are not migrating the database.</li>
</ol>
<pre><code>@Database(entities = {Word.class}, version = 1, exportSchema = false)</code></pre>
<ol type="1" start="3">
<li>Define the DAOs that work with the database. Provide an abstract &#34;getter&#34; method for each <code>@Dao</code>.</li>
</ol>
<pre><code>public abstract WordDao wordDao();</code></pre>
<ol type="1" start="4">
<li>Create the <code>WordRoomDatabase</code> as a <a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank">singleton</a> to prevent having multiple instances of the database opened at the same time, which would be a bad thing. Here is the code to create the singleton:</li>
</ol>
<pre><code>private static WordRoomDatabase INSTANCE;

public static WordRoomDatabase getDatabase(final Context context) {
   if (INSTANCE == null) {
       synchronized (WordRoomDatabase.class) {
           if (INSTANCE == null) {
               // Create database here
           }
       }
   }
   return INSTANCE;
}</code></pre>
<ol type="1" start="5">
<li>Add code to create a database where indicated by the <code>Create database here</code> comment in the code above.</li>
</ol>
<p>The following code uses Room&#39;s database builder to create a <a href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.html" target="_blank"><code>RoomDatabase</code></a> object named <code>&#34;word_database&#34;</code> in the application context from the <code>WordRoomDatabase</code> class.</p>
<pre><code>// Create database here
INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
       WordRoomDatabase.class, &#34;word_database&#34;)
       .build();</code></pre>
<ol type="1" start="6">
<li>Add a migration strategy for the database.</li>
</ol>
<p>In this practical you don&#39;t update the entities and the version numbers. However, if you modify the database schema, you need to update the version number and define how to handle migrations. For a sample app such as the one you&#39;re creating, destroying and re-creating the database is a fine migration strategy. For a real app, you must implement a non-destructive migration strategy. See <a href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929" target="_blank">Understanding migrations with Room</a>.</p>
<p>Add the following code to the builder, before calling <code>build()</code></p>
<pre><code>// Wipes and rebuilds instead of migrating 
// if no Migration object.
// Migration is not part of this practical.
.fallbackToDestructiveMigration()</code></pre>
<p>Here is the complete code for the whole <code>WordRoomDatabase</code> class:</p>
<pre><code>@Database(entities = {Word.class}, version = 1, exportSchema = false)
public abstract class WordRoomDatabase extends RoomDatabase {

   public abstract WordDao wordDao();
   private static WordRoomDatabase INSTANCE;

   static WordRoomDatabase getDatabase(final Context context) {
       if (INSTANCE == null) {
           synchronized (WordRoomDatabase.class) {
               if (INSTANCE == null) {
                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
                           WordRoomDatabase.class, &#34;word_database&#34;)
                             // Wipes and rebuilds instead of migrating 
                             // if no Migration object.
                            // Migration is not part of this practical.
                           .fallbackToDestructiveMigration()
                           .build();                
               }
           }
       }
       return INSTANCE;
   }
}</code></pre>
<aside class="warning"><p><strong>Important</strong>: In Android Studio, if you get errors when you paste code or during the build process, make sure you are using the full package name for imports. See <a href="https://developer.android.com/topic/libraries/architecture/adding-components.html" target="_blank">Adding Components to your Project</a>. Then select <strong>Build &gt; Clean Project</strong>. Then select <strong>Build &gt; Rebuild Project</strong>, and build again.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 6: Create the Repository" duration="0">
        <p class="image-container"><img style="width: 379.00px" src="img/f510e53aec891d19.png"></p>
<p>A <em>Repository</em> is a class that abstracts access to multiple data sources. The Repository is not part of the Architecture Components libraries, but is a suggested best practice for code separation and architecture. A <code>Repository</code> class handles data operations. It provides a clean API to the rest of the app for app data.</p>
<p class="image-container"><img style="width: 525.00px" src="img/2b9726b57b0d07f0.png"></p>
<p>A Repository manages query threads and allows you to use multiple backends. In the most common example, the Repository implements the logic for deciding whether to fetch data from a network or use results cached in the local database.</p>
<h2 is-upgraded>6.1 Implement the Repository</h2>
<ol type="1" start="1">
<li>Create a public class called <code>WordRepository</code>.</li>
<li>Add member variables for the DAO and the list of words.</li>
</ol>
<pre><code>private WordDao mWordDao;
private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</code></pre>
<ol type="1" start="3">
<li>Add a constructor that gets a handle to the database and initializes the member variables.</li>
</ol>
<pre><code>WordRepository(Application application) {
    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);
    mWordDao = db.wordDao();
    mAllWords = mWordDao.getAllWords();
}</code></pre>
<ol type="1" start="4">
<li>Add a wrapper method called <code>getAllWords()</code> that returns the cached words as <code>LiveData</code>. Room executes all queries on a separate thread. Observed <code>LiveData</code> notifies the observer when the data changes.</li>
</ol>
<pre><code>LiveData&lt;List&lt;Word&gt;&gt; getAllWords() {
   return mAllWords;
}</code></pre>
<ol type="1" start="5">
<li>Add a wrapper for the <code>insert()</code> method. Use an <code>AsyncTask</code> to call <code>insert()</code> on a non-UI thread, or your app will crash. Room ensures that you don&#39;t do any long-running operations on the main thread, which would block the UI.</li>
</ol>
<pre><code>public void insert (Word word) {
    new insertAsyncTask(mWordDao).execute(word);
}</code></pre>
<ol type="1" start="6">
<li>Create the <code>insertAsyncTask</code> as an inner class. You should be familiar with <code>AsyncTask</code>, so here is the <code>insertAsyncTask</code> code for you to copy:</li>
</ol>
<pre><code>private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; {

    private WordDao mAsyncTaskDao;

    insertAsyncTask(WordDao dao) {
        mAsyncTaskDao = dao;
    }

    @Override
    protected Void doInBackground(final Word... params) {
        mAsyncTaskDao.insert(params[0]);
        return null;
    }
}</code></pre>
<p>Here is the complete code for the <code>WordRepository</code> class:</p>
<pre><code>public class WordRepository {

   private WordDao mWordDao;
   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;

   WordRepository(Application application) {
       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);
       mWordDao = db.wordDao();
       mAllWords = mWordDao.getAllWords();
   }

   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() {
       return mAllWords;
   }

   public void insert (Word word) {
       new insertAsyncTask(mWordDao).execute(word);
   }

   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; {

       private WordDao mAsyncTaskDao;

       insertAsyncTask(WordDao dao) {
           mAsyncTaskDao = dao;
       }

       @Override
       protected Void doInBackground(final Word... params) {
           mAsyncTaskDao.insert(params[0]);
           return null;
       }
   }
}</code></pre>
<aside class="special"><p><strong>Note</strong>: For this simple example, the Repository doesn&#39;t do much. For a more complex implementation, see the <a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample" target="_blank">BasicSample</a> code on GitHub.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 7: Create the ViewModel" duration="0">
        <p class="image-container"><img style="width: 390.00px" src="img/b89cac6a40acebfe.png"></p>
<p>The <code>ViewModel</code> is a class whose role is to provide data to the UI and survive configuration changes. A <code>ViewModel</code> acts as a communication center between the Repository and the UI. The <code>ViewModel</code> is part of the <a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" target="_blank">lifecycle library</a>. For an introductory guide to this topic, see <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank"><code>ViewModel</code></a>.</p>
<p class="image-container"><img style="width: 513.00px" src="img/adc613dd05fd7ab.png"></p>
<p>A <code>ViewModel</code> holds your app&#39;s UI data in a way that survives configuration changes. Separating your app&#39;s UI data from your <code>Activity</code> and <code>Fragment</code> classes lets you better follow the single responsibility principle: Your activities and fragments are responsible for drawing data to the screen, while your <code>ViewModel</code> is responsible for holding and processing all the data needed for the UI.</p>
<p>In the <code>ViewModel</code>, use <code>LiveData</code> for changeable data that the UI will use or display.</p>
<h2 is-upgraded>7.1 Implement the WordViewModel</h2>
<ol type="1" start="1">
<li>Create a class called <code>WordViewModel</code> that extends <a href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html" target="_blank"><code>AndroidViewModel</code></a>.</li>
</ol>
<aside class="warning"><p><strong>Warning</strong>:</p>
<ul>
<li>Never pass context into <code>ViewModel</code> instances.</li>
<li>Do not store <code>Activity</code>, <code>Fragment</code>, or <code>View</code> instances or their <code>Context</code> in the <code>ViewModel</code>.</li>
</ul>
</aside>
<p>An <code>Activity</code> can be destroyed and created many times during the lifecycle of a <code>ViewModel</code>, such as when the device is rotated. If you store a reference to the <code>Activity</code> in the <code>ViewModel</code>, you end up with references that point to the destroyed <code>Activity</code>. This is a memory leak. If you need the application context, use <a href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html" target="_blank"><code>AndroidViewModel</code></a>, as shown in this practical.</p>
<pre><code>public class WordViewModel extends AndroidViewModel {}</code></pre>
<ol type="1" start="2">
<li>Add a private member variable to hold a reference to the Repository.</li>
</ol>
<pre><code>  private WordRepository mRepository;</code></pre>
<ol type="1" start="3">
<li>Add a private <code>LiveData</code> member variable to cache the list of words.</li>
</ol>
<pre><code> private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</code></pre>
<ol type="1" start="4">
<li>Add a constructor that gets a reference to the <code>WordRepository</code> and gets the list of all words from the <code>WordRepository</code>.</li>
</ol>
<pre><code>  public WordViewModel (Application application) {
       super(application);
       mRepository = new WordRepository(application);
       mAllWords = mRepository.getAllWords();
   }</code></pre>
<ol type="1" start="5">
<li>Add a &#34;getter&#34; method that gets all the words. This completely hides the implementation from the UI.</li>
</ol>
<pre><code>  LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; }</code></pre>
<ol type="1" start="6">
<li>Create a wrapper <code>insert()</code> method that calls the Repository&#39;s <code>insert()</code> method. In this way, the implementation of <code>insert()</code> is completely hidden from the UI.</li>
</ol>
<pre><code>public void insert(Word word) { mRepository.insert(word); }</code></pre>
<p>Here is the complete code for <code>WordViewModel</code>:</p>
<pre><code>public class WordViewModel extends AndroidViewModel {

   private WordRepository mRepository;

   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;

   public WordViewModel (Application application) {
       super(application);
       mRepository = new WordRepository(application);
       mAllWords = mRepository.getAllWords();
   }

   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; }

   public void insert(Word word) { mRepository.insert(word); }
}</code></pre>
<p>To learn more, watch the <a href="https://www.youtube.com/watch?v=c9-057jC1ZA" target="_blank">Architecture Components: <code>ViewModel</code></a> video.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 8: Add XML layouts for the UI" duration="0">
        <p>Next, add the XML layout for the list and items to be displayed in the <code>RecyclerView</code>.</p>
<p>This practical assumes that you are familiar with creating layouts in XML, so the code is just provided.</p>
<h2 is-upgraded>8.1 Add styles</h2>
<ol type="1" start="1">
<li>Change the colors in <code>colors.xml</code> to the following: (to use Material Design colors):</li>
</ol>
<pre><code>&lt;resources&gt;
   &lt;color name=&#34;colorPrimary&#34;&gt;#2196F3&lt;/color&gt;
   &lt;color name=&#34;colorPrimaryLight&#34;&gt;#64b5f6&lt;/color&gt;
   &lt;color name=&#34;colorPrimaryDark&#34;&gt;#1976D2&lt;/color&gt;
   &lt;color name=&#34;colorAccent&#34;&gt;#FFFF9800&lt;/color&gt;
   &lt;color name=&#34;colorTextPrimary&#34;&gt;@android:color/white&lt;/color&gt;
   &lt;color name=&#34;colorScreenBackground&#34;&gt;#fff3e0&lt;/color&gt;
   &lt;color name=&#34;colorTextHint&#34;&gt;#E0E0E0&lt;/color&gt;
&lt;/resources&gt;</code></pre>
<ol type="1" start="2">
<li>Add a style for text views in the <code>values/styles.xml</code> file:</li>
</ol>
<pre><code>&lt;style name=&#34;text_view_style&#34;&gt;
   &lt;item name=&#34;android:layout_width&#34;&gt;match_parent&lt;/item&gt;
   &lt;item name=&#34;android:layout_height&#34;&gt;wrap_content&lt;/item&gt;
   &lt;item name=&#34;android:textAppearance&#34;&gt;
      @android:style/TextAppearance.Large&lt;/item&gt;
   &lt;item name=&#34;android:background&#34;&gt;@color/colorPrimaryLight&lt;/item&gt;
   &lt;item name=&#34;android:layout_marginTop&#34;&gt;8dp&lt;/item&gt;
   &lt;item name=&#34;android:layout_gravity&#34;&gt;center&lt;/item&gt;
   &lt;item name=&#34;android:padding&#34;&gt;16dp&lt;/item&gt;
   &lt;item name=&#34;android:textColor&#34;&gt;@color/colorTextPrimary&lt;/item&gt;
&lt;/style&gt;</code></pre>
<h2 is-upgraded>8.2 Add item layout</h2>
<ul>
<li>Add a <code>layout/recyclerview_item.xml</code> layout:</li>
</ul>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;LinearLayout xmlns:android=
      &#34;http://schemas.android.com/apk/res/android&#34;
   android:orientation=&#34;vertical&#34; android:layout_width=&#34;match_parent&#34;
   xmlns:tools=&#34;http://schemas.android.com/tools&#34;
   android:layout_height=&#34;wrap_content&#34;&gt;

   &lt;TextView
       android:id=&#34;@+id/textView&#34;
       android:layout_width=&#34;match_parent&#34;
       android:layout_height=&#34;wrap_content&#34;
       style=&#34;@style/text_view_style&#34;
       tools:text=&#34;placeholder text&#34; /&gt;
&lt;/LinearLayout&gt;</code></pre>
<h2 is-upgraded>8.3 Add the RecyclerView</h2>
<ol type="1" start="1">
<li>In the <code>layout/content_main.xml</code> file, add a background color to the <code>ConstraintLayout</code>:</li>
</ol>
<pre><code>android:background=&#34;@color/colorScreenBackground&#34;</code></pre>
<ol type="1" start="2">
<li>In <code>content_main.xml</code> file, replace the <code>TextView</code> element with a <code>RecyclerView</code> element:</li>
</ol>
<pre><code>&lt;androidx.recyclerview.widget.RecyclerView
   android:id=&#34;@+id/recyclerview&#34;
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;wrap_content&#34;
   android:layout_margin=&#34;16dp&#34;
   tools:listitem=&#34;@layout/recyclerview_item&#34;
/&gt;</code></pre>
<h2 is-upgraded>8.4 Fix the icon in the FAB</h2>
<p>The icon in your floating action button (FAB) should correspond to the available action. In the <code>layout/activity_main.xml</code> file, give the <code>FloatingActionButton</code> a <code>+</code> symbol icon:</p>
<ol type="1" start="1">
<li>Select <strong>File &gt; New &gt; Vector Asset</strong>.</li>
<li>Select <strong>Material Icon</strong>.</li>
<li>Click the Android robot icon in the <strong>Icon</strong>: field, then select the <code>+</code> (&#34;add&#34;) asset.</li>
<li>In the <code>layout/activity_main.xml</code> file, in the <code>FloatingActionButton</code>, change the <code>srcCompat</code> attribute to:</li>
</ol>
<pre><code>android:src=&#34;@drawable/ic_add_black_24dp&#34;</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 9 Create an Adapter and adding the RecyclerView" duration="0">
        <p>You are going to display the data in a <code>RecyclerView</code>, which is a little nicer than just throwing the data in a <code>TextView</code>. This practical assumes that you know how <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" target="_blank"><code>RecyclerView</code></a>, <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html" target="_blank"><code>RecyclerView.LayoutManager</code></a>, <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html" target="_blank"><code>RecyclerView.ViewHolder</code></a>, and <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank"><code>RecyclerView.Adapter</code></a> work.</p>
<h2 is-upgraded>9.1 Create the WordListAdapter class</h2>
<ul>
<li>Add a class <code>WordListAdapter</code> that extends <code>RecyclerView.Adapter</code>. The adapter caches data and populates the <code>RecyclerView</code> with it. The inner class <code>WordViewHolder</code> holds and manages a view for one list item.</li>
</ul>
<p>Here is the code:</p>
<pre><code>public class WordListAdapter extends RecyclerView.Adapter&lt;WordListAdapter.WordViewHolder&gt; {

   private final LayoutInflater mInflater;
   private List&lt;Word&gt; mWords; // Cached copy of words

   WordListAdapter(Context context) { mInflater = LayoutInflater.from(context); }

   @Override
   public WordViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
       View itemView = mInflater.inflate(R.layout.recyclerview_item, parent, false);
       return new WordViewHolder(itemView);
   }

   @Override
   public void onBindViewHolder(WordViewHolder holder, int position) {
       if (mWords != null) {
           Word current = mWords.get(position);
           holder.wordItemView.setText(current.getWord());
       } else {
           // Covers the case of data not being ready yet.
           holder.wordItemView.setText(&#34;No Word&#34;);
       }
   }

   void setWords(List&lt;Word&gt; words){
       mWords = words;
       notifyDataSetChanged();
   }

   // getItemCount() is called many times, and when it is first called,
   // mWords has not been updated (means initially, it&#39;s null, and we can&#39;t return null).
   @Override
   public int getItemCount() {
       if (mWords != null)
           return mWords.size();
       else return 0;
   }

   class WordViewHolder extends RecyclerView.ViewHolder {
       private final TextView wordItemView;

       private WordViewHolder(View itemView) {
           super(itemView);
           wordItemView = itemView.findViewById(R.id.textView);
       }
   }
}</code></pre>
<aside class="special"><p><strong>Note</strong>: The <code>mWords</code> variable in the adapter caches the data. In the next task, you add the code that updates the data automatically.</p>
</aside>
<aside class="special"><p><strong>Note</strong>: The <code>getItemCount()</code> method needs to account gracefully for the possibility that the data is not yet ready and <code>mWords</code> is still <code>null</code>. In a more sophisticated app, you could display placeholder data or something else that would be meaningful to the user.</p>
</aside>
<h2 is-upgraded>9.2 Add RecyclerView to MainActivity</h2>
<ol type="1" start="1">
<li>Add the <code>RecyclerView</code> in the <code>onCreate()</code> method of <code>MainActivity</code>:</li>
</ol>
<pre><code>RecyclerView recyclerView = findViewById(R.id.recyclerview);
final WordListAdapter adapter = new WordListAdapter(this);
recyclerView.setAdapter(adapter);
recyclerView.setLayoutManager(new LinearLayoutManager(this));</code></pre>
<ol type="1" start="2">
<li>Run your app to make sure the app compiles and runs. There are no items, because you have not hooked up the data yet. The app should display the empty recycler view.</li>
</ol>
<p class="image-container"><img style="width: 234.84px" src="img/27d93b892545bbed.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 10: Populate the database" duration="0">
        <p>There is no data in the database yet. You will add data in two ways: Add some data when the database is opened, and add an <code>Activity</code> for adding words. Every time the database is opened, all content is deleted and repopulated. This is a reasonable solution for a sample app, where you usually want to restart on a clean slate.</p>
<h2 is-upgraded>10.1 Create the callback for populating the database</h2>
<p>To delete all content and repopulate the database whenever the app is started, you create a <code>RoomDatabase.Callback</code> and override the <code>onOpen()</code> method. Because you cannot do Room database operations on the UI thread, <code>onOpen()</code> creates and executes an <code>AsyncTask</code> to add content to the database.</p>
<ol type="1" start="1">
<li>Add the <code>onOpen()</code> callback in the <code>WordRoomDatabase</code> class:</li>
</ol>
<pre><code>private static RoomDatabase.Callback sRoomDatabaseCallback = 
    new RoomDatabase.Callback(){

    @Override
    public void onOpen (@NonNull SupportSQLiteDatabase db){
        super.onOpen(db);
       new PopulateDbAsync(INSTANCE).execute();
   }
};</code></pre>
<ol type="1" start="2">
<li>Create an inner class <code>PopulateDbAsync</code> that extends <code>AsycTask</code>. Implement the <code>doInBackground()</code> method to delete all words, then create new ones. Here is the code for the <code>AsyncTask</code> that deletes the contents of the database, then populates it with an initial list of words. Feel free to use your own words!</li>
</ol>
<pre><code>/**
* Populate the database in the background.
*/
private static class PopulateDbAsync extends AsyncTask&lt;Void, Void, Void&gt; {

   private final WordDao mDao;
   String[] words = {&#34;dolphin&#34;, &#34;crocodile&#34;, &#34;cobra&#34;};

   PopulateDbAsync(WordRoomDatabase db) {
       mDao = db.wordDao();
   }

   @Override
   protected Void doInBackground(final Void... params) {
       // Start the app with a clean database every time.
       // Not needed if you only populate the database
       // when it is first created
       mDao.deleteAll();

       for (int i = 0; i &lt;= words.length - 1; i++) {
           Word word = new Word(words[i]);
           mDao.insert(word);
       }
       return null;
   }
}</code></pre>
<ol type="1" start="3">
<li>Add the callback to the database build sequence in <code>WordRoomDatabase</code>, right before you call <code>.build()</code>:</li>
</ol>
<pre><code>.addCallback(sRoomDatabaseCallback)</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 11: Connect the UI with the data" duration="0">
        <p>Now that you have created the method to populate the database with the initial set of words, the next step is to add the code to display those words in the <code>RecyclerView</code>.</p>
<p>To display the current contents of the database, you add an observer that observes the <code>LiveData</code> in the <code>ViewModel</code>. Whenever the data changes (including when it is initialized), the <code>onChanged()</code> callback is invoked. In this case, the <code>onChanged()</code> callback calls the adapter&#39;s <code>setWord()</code> method to update the adapter&#39;s cached data and refresh the displayed list.</p>
<h2 is-upgraded>11.1 Display the words</h2>
<ol type="1" start="1">
<li>In <code>MainActivity</code>, create a member variable for the <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank"><code>ViewModel</code></a>, because all the activity&#39;s interactions are with the <code>WordViewModel</code> only.</li>
</ol>
<pre><code>private WordViewModel mWordViewModel;</code></pre>
<ol type="1" start="2">
<li>In the <code>onCreate()</code> method, get a <code>ViewModel</code> from the <code>ViewModelProviders</code> class.</li>
</ol>
<pre><code>mWordViewModel = new ViewModelProvider(this).get(WordViewModel.class);</code></pre>
<p>Use <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html" target="_blank"><code>ViewModelProviders</code></a> to associate your <code>ViewModel</code> with your UI controller. When your app first starts, the <code>ViewModelProviders</code> class creates the <code>ViewModel</code>. When the activity is destroyed, for example through a configuration change, the <code>ViewModel</code> persists. When the activity is re-created, the <code>ViewModelProviders</code> return the existing <code>ViewModel</code>. See <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank"><code>ViewModel</code></a>.</p>
<ol type="1" start="3">
<li>Also in <code>onCreate()</code>, add an observer for the <code>LiveData</code> returned by <code>getAllWords()</code>.<br>When the observed data changes while the activity is in the foreground, the <code>onChanged()</code> method is invoked and updates the data cached in the adapter. Note that in this case, when the app opens, the initial data is added, so <code>onChanged()</code> method is called.</li>
</ol>
<pre><code>mWordViewModel.getAllWords().observe(this, new Observer&lt;List&lt;Word&gt;&gt;() {
   @Override
   public void onChanged(@Nullable final List&lt;Word&gt; words) {
       // Update the cached copy of the words in the adapter.
       adapter.setWords(words);
   }
});</code></pre>
<ol type="1" start="4">
<li>Run the app. The initial set of words appears in the <code>RecyclerView</code>.<br><br><img style="width: 288.00px" src="img/c46b737aee2da6e1.png"></li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Tâche 12: Create an Activity for adding words" duration="0">
        <p>Now you will add an Activity that lets the user use the FAB to enter new words. This is what the interface for the new activity will look like:</p>
<p class="image-container"><img style="width: 288.00px" src="img/f59f81ad6aadfe12.png"></p>
<h2 is-upgraded>12.1 Create the NewWordActivity</h2>
<ol type="1" start="1">
<li>Add these string resources in the <code>values/strings.xml</code> file:</li>
</ol>
<pre><code>&lt;string name=&#34;hint_word&#34;&gt;Word...&lt;/string&gt;
&lt;string name=&#34;button_save&#34;&gt;Save&lt;/string&gt;
&lt;string name=&#34;empty_not_saved&#34;&gt;Word not saved because it is empty.&lt;/string&gt;</code></pre>
<ol type="1" start="2">
<li>Add a style for buttons in <code>value/styles.xml</code>:</li>
</ol>
<pre><code>&lt;style name=&#34;button_style&#34; parent=&#34;android:style/Widget.Material.Button&#34;&gt;
   &lt;item name=&#34;android:layout_width&#34;&gt;match_parent&lt;/item&gt;
   &lt;item name=&#34;android:layout_height&#34;&gt;wrap_content&lt;/item&gt;
   &lt;item name=&#34;android:background&#34;&gt;@color/colorPrimaryDark&lt;/item&gt;
   &lt;item name=&#34;android:textAppearance&#34;&gt;@android:style/TextAppearance.Large&lt;/item&gt;
   &lt;item name=&#34;android:layout_marginTop&#34;&gt;16dp&lt;/item&gt;
   &lt;item name=&#34;android:textColor&#34;&gt;@color/colorTextPrimary&lt;/item&gt;
&lt;/style&gt;</code></pre>
<ol type="1" start="3">
<li>Use the Empty Activity template to create a new activity, <code>NewWordActivity</code>. Verify that the activity has been added to the Android Manifest.</li>
</ol>
<pre><code>&lt;activity android:name=&#34;.NewWordActivity&#34;&gt;&lt;/activity&gt;</code></pre>
<ol type="1" start="4">
<li>Update the <code>activity_new_word.xml</code> file in the layout folder:</li>
</ol>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;match_parent&#34;
   android:background=&#34;@color/colorScreenBackground&#34;
   android:orientation=&#34;vertical&#34;
   android:padding=&#34;24dp&#34;&gt;

   &lt;EditText
       android:id=&#34;@+id/edit_word&#34;
       style=&#34;@style/text_view_style&#34;
       android:hint=&#34;@string/hint_word&#34;
       android:inputType=&#34;textAutoComplete&#34; /&gt;

   &lt;Button
       android:id=&#34;@+id/button_save&#34;
       style=&#34;@style/button_style&#34;
       android:text=&#34;@string/button_save&#34; /&gt;
&lt;/LinearLayout&gt;</code></pre>
<ol type="1" start="5">
<li>Implement the <code>NewWordActivity</code> class. The goal is that when the user presses the Save button, the new word is put in an <code>Intent</code> to be sent back to the parent <code>Activity</code>.</li>
</ol>
<p>Here is the code for the <code>NewWordActivity</code> activity:</p>
<pre><code>public class NewWordActivity extends AppCompatActivity {
   public static final String EXTRA_REPLY = 
             &#34;com.example.android.roomwordssample.REPLY&#34;;

   private  EditText mEditWordView;

   @Override
   public void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.activity_new_word);
       mEditWordView = findViewById(R.id.edit_word);

       final Button button = findViewById(R.id.button_save);
       button.setOnClickListener(new View.OnClickListener() {
           public void onClick(View view) {
               Intent replyIntent = new Intent();
               if (TextUtils.isEmpty(mEditWordView.getText())) {
                   setResult(RESULT_CANCELED, replyIntent);
               } else {
                   String word = mEditWordView.getText().toString();
                   replyIntent.putExtra(EXTRA_REPLY, word);
                   setResult(RESULT_OK, replyIntent);
               }
               finish();
           }
       });
   }
}</code></pre>
<h2 is-upgraded>12.2 Add code to insert a word into the database</h2>
<ol type="1" start="1">
<li>In <code>MainActivity</code>, add the <code>onActivityResult()</code> callback for the <code>NewWordActivity</code>. If the activity returns with <code>RESULT_OK</code>, insert the returned word into the database by calling the <code>insert()</code> method of the <code>WordViewModel</code>.</li>
</ol>
<pre><code>public void onActivityResult(int requestCode, int resultCode, Intent data) {
   super.onActivityResult(requestCode, resultCode, data);

   if (requestCode == NEW_WORD_ACTIVITY_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {
       Word word = new Word(data.getStringExtra(NewWordActivity.EXTRA_REPLY));
       mWordViewModel.insert(word);
   } else {
       Toast.makeText(
               getApplicationContext(),
               R.string.empty_not_saved,
               Toast.LENGTH_LONG).show();
   }
}</code></pre>
<ol type="1" start="2">
<li>Define the missing request code:</li>
</ol>
<pre><code>public static final int NEW_WORD_ACTIVITY_REQUEST_CODE = 1;</code></pre>
<ol type="1" start="3">
<li>In <code>MainActivity</code>,start <code>NewWordActivity</code> when the user taps the FAB. Replace the code in the FAB&#39;s <code>onClick()</code> click handler with the following code:</li>
</ol>
<pre><code>Intent intent = new Intent(MainActivity.this, NewWordActivity.class);
startActivityForResult(intent, NEW_WORD_ACTIVITY_REQUEST_CODE);</code></pre>
<ol type="1" start="4">
<li>Run your app. When you add a word to the database in <code>NewWordActivity</code>, the UI automatically updates.</li>
<li>Add a word that already exists in the list. What happens? Does your app crash?<br>Your app uses the word itself as the primary key, and each primary key <strong>must</strong> be unique.<br>You can specify a conflict strategy to tell your app what to do when the user tries to add an existing word.</li>
<li>In the <code>WordDao</code> interface, change the annotation for the <code>insert()</code> method to:</li>
</ol>
<pre><code>@Insert(onConflict = OnConflictStrategy.IGNORE)</code></pre>
<p>To learn about other conflict strategies, see the <a href="https://developer.android.com/reference/android/arch/persistence/room/OnConflictStrategy.html" target="_blank"><code>OnConflictStrategy</code></a> reference.</p>
<ol type="1" start="7">
<li>Run your app again and try adding a word that already exists. What happens now?</li>
</ol>
<h2 is-upgraded>Solution code</h2>
<p>Android Studio project: <a href="https://github.com/khammami/android-fundamentals-exycodelabs/tree/master/RoomWordsSample" target="_blank">RoomWordsSample</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Résumé" duration="0">
        <p>Now that you have a working app, let&#39;s recap what you&#39;ve built. Here is the app structure again, from the beginning:</p>
<ul>
<li>You have an app that displays words in a list (<code>MainActivity</code>, <code>RecyclerView</code>, <code>WordListAdapter</code>).</li>
<li>You can add words to the list (<code>NewWordActivity</code>).</li>
<li>A word is an instance of the <code>Word</code> entity class.</li>
<li>The words are cached in the <code>RecyclerViewAdapter</code> as a <code>List</code> of words (<code>mWords</code>). The list is automatically updated and redisplayed when the data changes.</li>
<li>The automatic update happens because in the <code>MainActivity</code>, there is an <code>Observer</code> that observes the words and is notified when the words change. When there is a change, the observer&#39;s <code>onChange()</code> method is executed and updates <code>mWords</code> in the <code>WordListAdapter</code>.</li>
<li>The data can be observed because it is <code>LiveData</code>. And what is observed is the <code>LiveData&lt;List&lt;Word&gt;&gt;</code> that is returned by the <code>WordViewModel</code> object.</li>
<li>The <code>WordViewModel</code> hides everything about the backend from the user interface. It provides methods for accessing the UI data, and it returns <code>LiveData</code> so that <code>MainActivity</code> can set up the observer relationship. Views, activities, and fragments only interact with the data through the <code>ViewModel</code>. As such, it doesn&#39;t matter where the data comes from.</li>
<li>In this case, the data comes from a Repository. The <code>ViewModel</code> does not need to know what that Repository interacts with. It just needs to know how to interact with the Repository, which is through the methods exposed by the Repository.</li>
<li>The Repository manages one or more data sources. In the RoomWordsSample app, that backend is a Room database. Room is a wrapper around and implements an SQLite database. Room does a lot of work for you that you used to have to do yourself. For example, Room does everything that you used to use an <code>SQLiteOpenHelper</code> class to do.</li>
<li>The DAO maps method calls to database queries, so that when the Repository calls a method such as <code>getAllWords()</code>, Room can execute <strong><code>SELECT * from word_table ORDER BY word ASC</code></strong>.</li>
<li>The result returned from the query is observed <code>LiveData</code>. Therefore, every time the data in Room changes, the <code>Observer</code> interface&#39;s <code>onChanged()</code> method is executed and the UI is updated.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Apprendre encore plus" duration="0">
        <p>To continue working with the RoomWordsSample app and learn more ways to use a Room database, see the <strong>4.2B: Deleting data from a Room database</strong> codelab, which takes up where this codelab leaves off.</p>
<p>Android developer documentation:</p>
<ul>
<li><a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank">Guide to App Architecture</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/adding-components.html" target="_blank">Adding Components to your Project</a></li>
<li><a href="https://developer.android.com/reference/android/arch/persistence/room/Dao.html" target="_blank">DAO</a></li>
<li><a href="https://developer.android.com/training/data-storage/room/accessing-data.html" target="_blank">Room DAOs</a></li>
<li><a href="https://developer.android.com/reference/android/arch/persistence/room/package-summary.html" target="_blank">Room package summary reference</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" target="_blank">Handling Lifecycles with Lifecycle-Aware Components</a></li>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank"><code>LiveData</code></a></li>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html" target="_blank"><code>MutableLiveData</code></a></li>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank"><code>ViewModel</code></a></li>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html" target="_blank"><code>ViewModelProviders</code></a></li>
<li><a href="https://developer.android.com/training/data-storage/room/defining-data.html" target="_blank">Defining data using Room entities</a></li>
</ul>
<p>Blogs and articles:</p>
<ul>
<li><a href="https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2" target="_blank">7 Steps To Room</a> (migrating an existing app)</li>
<li><a href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929" target="_blank">Understanding migrations with Room</a></li>
<li><a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4" target="_blank">Lifecycle Aware Data Loading with Architecture Components</a></li>
</ul>
<p>Codelabs:</p>
<ul>
<li><a href="https://codelabs.developers.google.com/codelabs/android-persistence/#0" target="_blank">Android Persistence codelab</a> (<code>LiveData</code>, Room, DAO)</li>
<li><a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" target="_blank">Android lifecycle-aware components codelab</a> (<code>ViewModel</code>, <code>LiveData</code>, <code>LifecycleOwner</code>, <code>LifecycleRegistryOwner</code>)</li>
</ul>
<p>Videos:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=vOJCrbr144o" target="_blank">Architecture Components</a> overview</li>
<li><a href="https://www.youtube.com/watch?v=jCw5ib0r9wg" target="_blank">Architecture Components: LiveData and Lifecycle</a></li>
<li><a href="https://www.youtube.com/watch?v=c9-057jC1ZA" target="_blank">Architecture Components: ViewModel</a></li>
</ul>
<p>Code samples:</p>
<ul>
<li><a href="https://github.com/googlesamples/android-architecture-components" target="_blank">Architecture Components code samples</a></li>
<li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample" target="_blank">BasicSample</a> (a not-so-basic but comprehensive sample)</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
